diff --git a/boot.c b/boot.c
index 9715a46..767523b 100644
--- a/boot.c
+++ b/boot.c
@@ -33,6 +33,7 @@ map_physical_memory(uintptr_t dram_base,
                     uintptr_t dram_size)
 {
   uintptr_t ptr = EYRIE_LOAD_START;
+  debug("Remapping phyiscal addresses: %llx -> %llx", dram_base, ptr);
   /* load address should not override kernel address */
   assert(RISCV_GET_PT_INDEX(ptr, 1) != RISCV_GET_PT_INDEX(runtime_va_start, 1));
   map_with_reserved_page_table(dram_base, dram_size,
@@ -46,6 +47,7 @@ remap_kernel_space(uintptr_t runtime_base,
   /* eyrie runtime is supposed to be smaller than a megapage */
   assert(runtime_size <= RISCV_GET_LVL_PGSIZE(2));
 
+  debug("Remapping phyiscal addresses: %llx -> %llx", runtime_base, runtime_va_start);
   map_with_reserved_page_table(runtime_base, runtime_size,
      runtime_va_start, kernel_l2_page_table, kernel_l3_page_table);
 }
@@ -63,6 +65,11 @@ copy_root_page_table()
         !(root_page_table[i] & PTE_V)) {
       root_page_table[i] = old_root_page_table[i];
     }
+    // if (old_root_page_table[i] & PTE_V) {
+    //   if ((old_root_page_table[i] & (PTE_R | PTE_W | PTE_X)) == 0){
+    //     debug("found second level page");
+    //   }
+    // }
   }
 }
 
@@ -70,6 +77,7 @@ copy_root_page_table()
 void
 init_freemem()
 {
+  debug("init free mem: %lx (%d Bytes)", freemem_va_start, freemem_size);
   spa_init(freemem_va_start, freemem_size);
 }
 
@@ -102,6 +110,120 @@ init_user_stack_and_env()
   csr_write(sscratch, user_sp);
 }
 
+void map_pt(pte * root_pt, pte * free1, pte * free0, uintptr_t va, uintptr_t pa, size_t size, int type) {
+  pte * pt1;
+  pte * pt0;
+  
+  // level 2: root page
+  int vpn2 = (va >> 30) & 0x1ff;
+  assert(vpn2 < 512);
+  if (root_pt[vpn2] & PTE_V) {
+    pt1 = (pte*) __va((pte_ppn(root_pt[vpn2]) << 12));
+    debug("root pt entry already exists");
+  }
+  else {
+    root_pt[vpn2] = ptd_create(ppn(kernel_va_to_pa(free1)));
+    pt1 = (pte*) __va((pte_ppn(root_pt[vpn2]) << 12));
+    debug("root pt entry had to be created");
+  }
+
+  debug("pt1: %lx", pt1);
+
+  // level 1
+  int vpn1 = (va >> 21) && 0x1ff;
+  assert(vpn1 < 512);
+  if (pt1[vpn1] & PTE_V) {
+    pt0 = (pte*) __va((pte_ppn(pt1[vpn1]) << 12));
+    debug("pt1 entry already exists");
+  }
+  else {
+    pt1[vpn1] = ptd_create(ppn(kernel_va_to_pa(free0)));
+    pt0 = (pte*) __va((pte_ppn(pt1[vpn1]) << 12));
+    debug("pt1 had to be created");
+  }
+
+  // lowest level
+  for(size_t i = 0; i < size; i += 4096) {
+    int vpn0 = ((va+i) >> 12) & 0x1ff;
+    assert(vpn0 < 512);
+    if(pt0[vpn0] & PTE_V) {
+      debug("This va has already been mapped: %lx", va + i);
+      assert(false);
+    }
+    pt0[vpn0] = pte_create(ppn(pa + i), type);
+  }
+  
+}
+
+// uintptr_t translate_mmu(pte * pt, int level, uintptr_t va) {
+//   int vpn = va >> (12 + level*9);
+//   assert(vpn < 512);
+//   // debug("walking: %lx, pte: %lx level: %d, curr_va: %lx", &pt[i], pt[i], level, curr_va);
+//   if(pt[vpn] & PTE_V) {
+//     if(pt[vpn] & (PTE_X | PTE_R)) {
+//       // page is leaf
+//       uintptr_t pa = pte_ppn(pt[vpn]) << 12;
+//       int f[8];
+//       for(int j = 0; j < 8; j++) {
+//         f[j] = (pt[vpn] >> j) & 0x1;
+//       }
+//       debug("PT (%lx): va: %lx, pa: %lx (level: %d) f: %d%d%d%d%d%d%d%d", 
+//         &pt[vpn], va, pa, level, f[7], f[6], f[5], f[4], f[3], f[2], f[1], f[0]);
+//       return pa;
+//     } 
+//     else {
+//       pte* next_level = (pte*) __va((pte_ppn(pt[vpn]) << 12));
+//       assert(level-1>=0);
+//       return translate_mmu(next_level, level-1, va); 
+//     }
+//   }
+//   debug("Could not translate va: %lx", va);
+//   return 0;
+// }
+
+// void walk_pt(pte * pt, int level, uintptr_t * curr_va) {
+//   for(int i = 0; i < 512; i++) {
+//     // debug("walking: %lx, pte: %lx level: %d, curr_va: %lx", &pt[i], pt[i], level, curr_va);
+//     if(pt[i] & PTE_V) {
+//       if(pt[i] & (PTE_X | PTE_R | PTE_W)) {
+//         // page is leaf
+//         uintptr_t pa = pte_ppn(pt[i]) << 12;
+//         // debug("Leaf page: ppn: %lx level: %d", pte_ppn(*walk), level);
+//         uintptr_t t = i;
+//         uintptr_t va = *curr_va | (t<<(level*9+12));
+
+//         int f[8];
+//         for(int j = 0; j < 8; j++) {
+//           f[j] = (pt[i] >> j) & 0x1;
+//         }
+
+//         debug("PT (%lx): va: %lx, pa: %lx (level: %d) f: %d%d%d%d%d%d%d%d", 
+//           &pt[i], va, pa, level, f[7], f[6], f[5], f[4], f[3], f[2], f[1], f[0]);
+//       } 
+//       else {
+//         pte* next_level = (pte*) __va((pte_ppn(pt[i]) << 12));
+//         assert(level-1>=0);
+//         uintptr_t t = i;
+//         uintptr_t next_va = *curr_va | (t<<(level*9+12));
+//         walk_pt(next_level, level-1, &next_va); 
+//       }
+//     }
+//   }
+// }
+
+void map_shared_memory(uintptr_t sem_base,
+                       uintptr_t sem_size, uintptr_t sem_entry)
+{
+  debug("Remapping phyiscal addresses: %llx -> %llx", sem_base, sem_entry);
+  /* load address should not override kernel address */
+  assert(RISCV_GET_PT_INDEX(sem_entry, 1) != RISCV_GET_PT_INDEX(runtime_va_start, 1));
+  map_pt(root_page_table, sem_l2_page_table, sem_l3_page_table, sem_entry, 
+    sem_base, sem_size, PTE_R | PTE_W | PTE_A | PTE_D | PTE_U | PTE_X);
+}
+
+extern void save_temp_reg(uintptr_t* sem_paddr, uintptr_t* sem_size, uintptr_t* sem_vaddr, 
+                          uintptr_t* con_paddr, uintptr_t* con_size, uintptr_t* con_vaddr);
+
 void
 eyrie_boot(uintptr_t dummy, // $a0 contains the return value from the SBI
            uintptr_t dram_base,
@@ -112,6 +234,10 @@ eyrie_boot(uintptr_t dummy, // $a0 contains the return value from the SBI
            uintptr_t utm_vaddr,
            uintptr_t utm_size)
 {
+  uintptr_t sem_paddr;
+  uintptr_t con_paddr, con_vaddr, con_size;
+  save_temp_reg(&sem_paddr, &sem_size, &sem, &con_paddr, &con_size, &con_vaddr);
+
   /* set initial values */
   load_pa_start = dram_base;
   shared_buffer = utm_vaddr;
@@ -119,8 +245,15 @@ eyrie_boot(uintptr_t dummy, // $a0 contains the return value from the SBI
   runtime_va_start = (uintptr_t) &rt_base;
   kernel_offset = runtime_va_start - runtime_paddr;
 
-  debug("UTM : 0x%lx-0x%lx (%u KB)", utm_vaddr, utm_vaddr+utm_size, utm_size/1024);
-  debug("DRAM: 0x%lx-0x%lx (%u KB)", dram_base, dram_base + dram_size, dram_size/1024);
+  debug("UTM (VA) : 0x%lx-0x%lx (%u KB)", utm_vaddr, utm_vaddr+utm_size, utm_size/1024);
+  debug("SEM (PA) : 0x%lx-0x%lx (%u KB)", sem_paddr, sem_paddr+sem_size, sem_size/1024);
+  debug("SEM (VA) : 0x%lx-0x%lx (%u KB)", sem, sem+sem_size, sem_size/1024);
+  debug("CON (PA) : 0x%lx-0x%lx (%u KB)", con_paddr, con_paddr+con_size, con_size/1024);
+  debug("CON (VA) : 0x%lx-0x%lx (%u KB)", con_vaddr, con_vaddr+con_size, con_size/1024);
+  debug("DRAM(PA) : 0x%lx-0x%lx (%u KB)", dram_base, dram_base + dram_size, dram_size/1024);
+  debug("USER(PA) : 0x%lx", user_paddr);
+  debug("RT  (PA) : 0x%lx", runtime_paddr);
+  debug("FREE(PA) : 0x%lx", free_paddr);
 #ifdef USE_FREEMEM
   freemem_va_start = __va(free_paddr);
   freemem_size = dram_base + dram_size - free_paddr;
@@ -134,6 +267,11 @@ eyrie_boot(uintptr_t dummy, // $a0 contains the return value from the SBI
   /* switch to the new page table */
   csr_write(satp, satp_new(kernel_va_to_pa(root_page_table)));
 
+  // debug("\n\nprint old page tables:");
+  // // // print_page_tables((pte *)EYRIE_LOAD_START, 0);
+  // uintptr_t curr_va = 0;
+  // walk_pt((pte *)EYRIE_LOAD_START, 2, &curr_va);
+
   /* copy valid entries from the old page table */
   copy_root_page_table();
 
@@ -144,6 +282,12 @@ eyrie_boot(uintptr_t dummy, // $a0 contains the return value from the SBI
   //highest used addr. Instead we start partway through the anon space
   set_program_break(EYRIE_ANON_REGION_START + (1024 * 1024 * 1024));
 
+  /* remap shared memory */
+  // if(con_paddr == 0x0) 
+    map_shared_memory(sem_paddr, sem_size, (uintptr_t) 0x200000);
+  // else
+    map_shared_memory(con_paddr, con_size, (uintptr_t) 0x220000);
+
   #ifdef USE_PAGING
   init_paging(user_paddr, free_paddr);
   #endif /* USE_PAGING */
@@ -164,6 +308,22 @@ eyrie_boot(uintptr_t dummy, // $a0 contains the return value from the SBI
   /* Enable the FPU */
   csr_write(sstatus, csr_read(sstatus) | 0x6000);
 
+  // debug("\n\nprint new page tables:");
+  // // print_page_tables(root_page_table, 0);
+  // curr_va = 0;
+  // walk_pt(root_page_table, 2, &curr_va);
+  // debug("done printing page tables");
+
+  // debug("sem access test");
+  // int* share = (int *)0x20000000;
+  // *share = 1337;
+  // debug("share val: %d", *share);
+
+  // debug("testing access 0x10090");
+  // debug("should be at pa: %lx", translate_mmu(root_page_table, 2, 0x10090));
+  // // int* code = (int *)0x10000;
+  // // debug("read: %d", *code);
+
   debug("eyrie boot finished. drop to the user land ...");
   /* booting all finished, droping to the user land */
   return;
diff --git a/common.h b/common.h
index 8bbd866..292dcb8 100644
--- a/common.h
+++ b/common.h
@@ -32,7 +32,7 @@
   printf ("[debug] " format " (%s:%d)\r\n", ## __VA_ARGS__, __FILE__, __LINE__)
 #else
 #define debug(format, ...) \
-  ;
+  // printf ("[debug] " format " (%s:%d)\r\n", ## __VA_ARGS__, __FILE__, __LINE__)
 #endif
 
 #define warn(format, ...) \
diff --git a/entry.S b/entry.S
index 2114b76..21bd88d 100644
--- a/entry.S
+++ b/entry.S
@@ -9,6 +9,9 @@
 
 #define ENCL_STACK_SIZE (8*1024)
 
+.global save_temp_reg
+.type save_temp_reg, @function
+
 .text
 //entry point to the runtime!
 .altmacro
@@ -128,6 +131,15 @@ _start:
   csrrw sp, sscratch, sp
   sret
 
+save_temp_reg:
+  STORE t3, 0(a0)
+  STORE t4, 0(a1)
+  STORE t5, 0(a2)
+  STORE s9, 0(a3)
+  STORE s10, 0(a4)
+  STORE s11, 0(a5)
+  ret
+
 .align 6
 encl_trap_handler:
   .global encl_trap_handler
diff --git a/mm.c b/mm.c
index 31c45fd..f85f675 100644
--- a/mm.c
+++ b/mm.c
@@ -192,7 +192,7 @@ __map_with_reserved_page_table(uintptr_t dram_base,
                                uintptr_t dram_size,
                                uintptr_t ptr,
                                pte* l2_pt,
-                               pte* l3_pt)
+                               pte* l3_pt, int type)
 {
   uintptr_t offset = 0;
   uintptr_t leaf_level = 3;
@@ -223,8 +223,7 @@ __map_with_reserved_page_table(uintptr_t dram_base,
        offset += RISCV_GET_LVL_PGSIZE(leaf_level))
   {
     leaf_pt[RISCV_GET_PT_INDEX(ptr + offset, leaf_level)] =
-      pte_create(ppn(dram_base + offset),
-          PTE_R | PTE_W | PTE_X | PTE_A | PTE_D);
+      pte_create(ppn(dram_base + offset), type);
   }
 }
 
@@ -236,9 +235,22 @@ map_with_reserved_page_table(uintptr_t dram_base,
                              pte* l3_pt)
 {
   if (dram_size > RISCV_GET_LVL_PGSIZE(2))
-    __map_with_reserved_page_table(dram_base, dram_size, ptr, l2_pt, 0);
+    __map_with_reserved_page_table(dram_base, dram_size, ptr, l2_pt, 0, PTE_R | PTE_W | PTE_X | PTE_A | PTE_D);
   else
-    __map_with_reserved_page_table(dram_base, dram_size, ptr, l2_pt, l3_pt);
+    __map_with_reserved_page_table(dram_base, dram_size, ptr, l2_pt, l3_pt, PTE_R | PTE_W | PTE_X | PTE_A | PTE_D);
+}
+
+void
+map_userspace_page_table(uintptr_t dram_base,
+                         uintptr_t dram_size,
+                         uintptr_t ptr,
+                         pte* l2_pt,
+                         pte* l3_pt)
+{
+  if (dram_size > RISCV_GET_LVL_PGSIZE(2))
+    __map_with_reserved_page_table(dram_base, dram_size, ptr, l2_pt, 0, PTE_U | PTE_R | PTE_W | PTE_X | PTE_A | PTE_D);
+  else
+    __map_with_reserved_page_table(dram_base, dram_size, ptr, l2_pt, l3_pt, PTE_U | PTE_R | PTE_W | PTE_X | PTE_A | PTE_D);
 }
 
 #endif /* USE_FREEMEM */
diff --git a/mm.h b/mm.h
index daa6eb4..fe0b0b4 100644
--- a/mm.h
+++ b/mm.h
@@ -17,6 +17,7 @@ uintptr_t get_program_break();
 void set_program_break(uintptr_t new_break);
 
 void map_with_reserved_page_table(uintptr_t base, uintptr_t size, uintptr_t ptr, pte* l2_pt, pte* l3_pt);
+void map_userspace_page_table(uintptr_t dram_base, uintptr_t dram_size, uintptr_t ptr, pte* l2_pt, pte* l3_pt);
 #endif /* USE_FREEMEM */
 
 #endif /* _MM_H_ */
diff --git a/rt_util.c b/rt_util.c
index a391d6c..fed5ec6 100644
--- a/rt_util.c
+++ b/rt_util.c
@@ -60,6 +60,7 @@ void rt_page_fault(struct encl_ctx* ctx)
   addr = ctx->sbadaddr;
   cause = ctx->scause;
   printf("[runtime] page fault at 0x%lx on 0x%lx (scause: 0x%lx)\r\n", pc, addr, cause);
+  printf("[runtime] trying to access (VA): 0x%lx, corresponding PA: 0x%lx\r\n", addr, translate(addr));
 #endif
 
   sbi_exit_enclave(-1);
diff --git a/syscall.c b/syscall.c
index 49587df..f58f694 100644
--- a/syscall.c
+++ b/syscall.c
@@ -70,6 +70,8 @@ uintptr_t dispatch_edgecall_ocall( unsigned long call_id,
    * the right place to put calls */
   struct edge_call* edge_call = (struct edge_call*)shared_buffer;
 
+  debug("Performing ocall with shared buffer: %llx", shared_buffer);
+
   /* We encode the call id, copy the argument data into the shared
    * region, calculate the offsets to the argument data, and then
    * dispatch the ocall to host */
diff --git a/vm.h b/vm.h
index 539ca0a..4456786 100644
--- a/vm.h
+++ b/vm.h
@@ -118,6 +118,10 @@ pte kernel_l3_page_table[BIT(RISCV_PT_INDEX_BITS)] __attribute__((aligned(RISCV_
 pte load_l2_page_table[BIT(RISCV_PT_INDEX_BITS)] __attribute__((aligned(RISCV_PAGE_SIZE)));
 pte load_l3_page_table[BIT(RISCV_PT_INDEX_BITS)] __attribute__((aligned(RISCV_PAGE_SIZE)));
 
+pte sem_l2_page_table[BIT(RISCV_PT_INDEX_BITS)] __attribute__((aligned(RISCV_PAGE_SIZE)));
+pte sem_l3_page_table[BIT(RISCV_PT_INDEX_BITS)] __attribute__((aligned(RISCV_PAGE_SIZE)));
+
+
 /* Program break */
 uintptr_t program_break;
 
@@ -130,5 +134,8 @@ size_t freemem_size;
 uintptr_t shared_buffer;
 uintptr_t shared_buffer_size;
 
+/* shared enclave memory */
+uintptr_t sem;
+uintptr_t sem_size;
 
 #endif
